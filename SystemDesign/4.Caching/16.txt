# Redis vs Memcached â€” End to End

## What problem they solve

Both are **in-memory data stores** used to:

* Reduce DB load
* Reduce latency
* Handle high read traffic
* Store temporary data

But **they are not interchangeable**.

---

## 1ï¸âƒ£ Memcached (simpler, dumber, faster)

### What it is

* Pure **key â†’ value** store
* Values are just **strings/bytes**
* No persistence
* No advanced features

Think:

> Memcached = fast shared hashmap

---

### Characteristics

| Feature      | Memcached    |
| ------------ | ------------ |
| Data type    | String only  |
| Persistence  | âŒ None       |
| Replication  | âŒ None       |
| Transactions | âŒ            |
| Pub/Sub      | âŒ            |
| TTL          | âœ…            |
| Speed        | ğŸ”¥ Very fast |
| Complexity   | Very low     |

---

### Typical use cases

âœ” Simple page cache
âœ” DB query result cache
âœ” Temporary computed values

Example:

```js
key: "home_page_data"
value: JSON string
TTL: 60 sec
```

---

### Why Memcached is declining

* No persistence
* No replication
* No HA
* No rich data structures
* Redis does **everything Memcached does + more**

---

## 2ï¸âƒ£ Redis (powerful, flexible, industry standard)

### What it is

* In-memory **data structure store**
* Can persist to disk
* Can replicate
* Can cluster
* Can do atomic operations

Think:

> Redis = in-memory database + cache + message broker

---

### Redis data types (this is HUGE)

| Type       | Use case       |
| ---------- | -------------- |
| String     | Simple cache   |
| Hash       | Object storage |
| List       | Queues         |
| Set        | Unique items   |
| Sorted Set | Leaderboards   |
| Streams    | Event logs     |

---

### Example: Object cache (better than JSON string)

```js
await redis.hset(`so:${id}`, {
  total: 10000,
  status: "APPROVED",
  customer: 5
});
```

Fetch partial data without deserializing everything.

---

### Redis persistence (critical difference)

* **RDB** â€“ snapshot every X seconds
* **AOF** â€“ append every write

So Redis **survives restarts**
Memcached does **not**.

---

### Redis features Memcached cannot do

âœ” Atomic increments
âœ” Distributed locks
âœ” Rate limiting
âœ” Pub/Sub
âœ” Streams
âœ” Transactions (MULTI)
âœ” Lua scripting

---

## 3ï¸âƒ£ Side-by-side comparison

| Feature        | Redis  | Memcached   |
| -------------- | ------ | ----------- |
| Data types     | Rich   | String only |
| Persistence    | âœ…      | âŒ           |
| Replication    | âœ…      | âŒ           |
| Clustering     | âœ…      | âŒ           |
| HA             | âœ…      | âŒ           |
| Atomic ops     | âœ…      | âŒ           |
| Complexity     | Medium | Low         |
| Industry usage | ğŸ”¥ğŸ”¥ğŸ”¥ | Declining   |

---

## 4ï¸âƒ£ What real companies use

* **Almost everyone uses Redis**
* Memcached exists mostly in **legacy systems**
* New systems â†’ Redis by default

If you say â€œMemcachedâ€ in interviews, expect:

> â€œWhy not Redis?â€

---

## 5ï¸âƒ£ How Redis fits your POS / finance system

### âŒ What NOT to cache

* Payment submission
* Ledger writes
* JV creation

---

### âœ… What TO cache (with short TTL)

| Data          | Redis Key                   | TTL  |
| ------------- | --------------------------- | ---- |
| SO list       | `so:list:companyId`         | 30s  |
| JV report     | `jv:report:companyId:month` | 30s  |
| Trial Balance | `tb:companyId`              | 60s  |
| Balance Sheet | `bs:companyId`              | 120s |
| Product list  | `product:list`              | 300s |

---

## 6ï¸âƒ£ Cache invalidation (finance-safe)

Example: Payment created

```js
await redis.del([
  `so:list:${companyId}`,
  `jv:report:${companyId}`,
  `tb:${companyId}`,
  `bs:${companyId}`
]);
```

You **invalidate**, not update.

---

## 7ï¸âƒ£ Redis is NOT just a cache (important)

Redis can also be used for:

* Rate limiting
* Job queues
* Locks (prevent double payment)
* Session storage
* Real-time notifications

But:

> **Do not mix critical data storage and cache logic blindly**

---

## 8ï¸âƒ£ Failure scenarios (system design thinking)

### If Redis goes down

* Backend must fall back to DB
* System should degrade gracefully
* No data loss (DB is source of truth)

If Redis failure breaks system â†’ **bad design**

---

## 9ï¸âƒ£ Brutal truth (for you)

If your design is:

> â€œRedis = faster DBâ€

Youâ€™re thinking shallow.

Correct thinking:

> â€œRedis protects DB, absorbs read spikes, and enables patterns DB cannot do efficiently.â€

---

## Interview-ready one-liner

> Redis is a distributed in-memory data store used as a cache and fast data structure layer to reduce database load, enable low-latency reads, and support patterns like rate limiting, locking, and pub/sub.

---