---

## What is caching (in one line)

**Caching = store data closer to where itâ€™s used, so you donâ€™t recompute or refetch it repeatedly.**

The key idea is **distance**:

> Closer to user â†’ faster â†’ cheaper â†’ less load

---

## Big picture (where caching exists)

```
User
 â†“
Browser (Client-side cache)
 â†“
CDN (Cloudflare)
 â†“
API Server
 â†“
Server-side Cache (Redis)
 â†“
Database
```

Now weâ€™ll break **client-side vs server-side** properly.

---

# 1ï¸âƒ£ Client-side Caching

**Cache lives on the userâ€™s device**
Browser, mobile app, local storage, memory.

### Common forms

* Browser cache (HTML, CSS, JS, images)
* HTTP cache (`Cache-Control`, `ETag`)
* LocalStorage / SessionStorage
* IndexedDB (for large data)
* In-memory cache (React state, Redux store)

---

### Example: Static files (React app)

When user hits:

```
https://yourapp.com/main.8d9f3a.js
```

Server response:

```
Cache-Control: public, max-age=31536000, immutable
```

#### What happens

* Browser downloads file once
* Stores it locally
* Next time â†’ **NO server hit**
* Page loads instantly

ğŸ‘‰ This is **client-side caching**

---

### Example: API response caching in browser

```http
GET /api/profile
Cache-Control: private, max-age=60
```

* Browser caches response for 60 seconds
* Refresh within 60 sec â†’ no API call
* After 60 sec â†’ re-fetch

---

### React example (implicit client cache)

```js
const [products, setProducts] = useState([]);
```

* Data stays in memory
* Route change â†’ data reused
* Hard refresh â†’ cache lost

Libraries like:

* React Query
* SWR

â†’ **formal client-side caching**

---

### âœ… Pros of Client-side Cache

âœ” Very fast (zero network)
âœ” Reduces server traffic
âœ” Free (no infra cost)

---

### âŒ Cons of Client-side Cache

âŒ User-specific (canâ€™t share across users)
âŒ Hard to invalidate correctly
âŒ Stale data risk
âŒ User can clear it anytime

---

### When to use client-side caching

* Static assets (JS, CSS, images)
* User profile data
* Read-heavy UI data
* Things that can be **slightly stale**

---

# 2ï¸âƒ£ Server-side Caching

**Cache lives on the server or infra**, shared by all users.

### Common types

* In-memory (Node process â€“ bad at scale)
* Redis / Memcached
* Database query cache
* CDN (also server-side, but edge-based)

---

### Example: Redis caching (your POS backend)

Without cache:

```
Client â†’ API â†’ MySQL â†’ API â†’ Client
```

With Redis:

```
Client â†’ API â†’ Redis (hit) â†’ Client
             â†“ (miss)
            MySQL
```

#### Code example (Node + Redis)

```js
const cached = await redis.get(`product:${id}`);
if (cached) {
  return JSON.parse(cached);
}

const product = await db.getProduct(id);
await redis.setex(`product:${id}`, 300, JSON.stringify(product));
return product;
```

---

### Example: Shared data (Categories)

* 1 category list
* 100,000 users
* Without cache â†’ 100,000 DB hits
* With Redis â†’ **1 DB hit**

This is where server-side cache **destroys client-side cache in impact**.

---

### CDN caching (Cloudflare)

Cloudflare caches:

* Images
* JS/CSS
* Public API responses

User in Delhi:

* Served from Delhi edge
* Your server in Mumbai never gets hit

---

### âœ… Pros of Server-side Cache

âœ” Shared across users
âœ” Massive DB load reduction
âœ” Controlled invalidation
âœ” Reliable

---

### âŒ Cons of Server-side Cache

âŒ Extra infrastructure
âŒ Needs eviction strategy
âŒ Cache consistency issues
âŒ Costs money

---

### When to use server-side caching

* Frequently accessed data
* Expensive DB queries
* Aggregated reports
* Read-heavy endpoints
* Cross-user shared data

---

# 3ï¸âƒ£ Client vs Server â€“ Side-by-side

| Aspect      | Client-side   | Server-side    |
| ----------- | ------------- | -------------- |
| Location    | Browser / App | Redis / Memory |
| Speed       | ğŸ”¥ Fastest    | Fast           |
| Shared      | âŒ No          | âœ… Yes          |
| Control     | âŒ Low         | âœ… High         |
| Persistence | âŒ Unreliable  | âœ… Reliable     |
| Cost        | Free          | Infra cost     |
| Use case    | UI & static   | Business data  |

---

# 4ï¸âƒ£ Real Production Rule (IMPORTANT)

> **Never choose one. Use BOTH.**

### Example: E-commerce product page

1. CDN caches product image
2. Browser caches JS/CSS
3. React Query caches API response
4. Redis caches product data
5. DB as final source of truth

This is **multi-layer caching**.

---

# 5ï¸âƒ£ Cache Invalidation (where most devs fail)

There are only **3 strategies**:

1. **TTL-based** (expire after time)
2. **Write-through** (update cache on DB write)
3. **Delete-on-write** (invalidate cache when data changes)

Example:

```js
await db.updateProduct(id, data);
await redis.del(`product:${id}`);
```

âŒ If you forget this â†’ **bugs, wrong data, finance issues**

---

# 6ï¸âƒ£ Brutal truth (for your level)

Right now:

* You know **how to use Redis**
* But system design expects:

  * **Where to cache**
  * **Why**
  * **What if cache fails**
  * **How stale is acceptable**

Thatâ€™s the difference between:

> â€œBackend developerâ€ âŒ
> â€œSystem-thinking engineerâ€ âœ…

---