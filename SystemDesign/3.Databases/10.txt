Perfect ‚Äî **Indexing, Partitioning, and Sharding** are the backbone of scalable databases.
I‚Äôll explain them end-to-end with diagrams, real use cases, interview points, and simple analogies.

---

# #Ô∏è‚É£ **1. Indexing (Speeding up Searches)**

Index = a **data structure** that helps the database find rows **faster** (like an index in a book).

### Without Index

DB scans the entire table üîç
‚Üí Slow for large data
‚Üí O(n)

### With Index

DB jumps directly to the row
‚Üí Fast
‚Üí O(log n)

---

## üü¢ **Types of Indexes**

### **1. B-Tree Index (Most common)**

* Sorted
* Supports range queries
* Used in: MySQL, PostgreSQL, Oracle

**Best for:**
`WHERE age > 30`
`ORDER BY name`
`BETWEEN queries`

---

### **2. Hash Index**

* Key ‚Üí Hash ‚Üí Direct lookup
* Super fast for equality queries
* NO range queries

**Best for:**
`WHERE id = 101`

Used in: Redis, DynamoDB, PostgreSQL (hash index)

---

### **3. Composite Index**

Index on multiple columns:

```
INDEX (city, age)
```

Helps:

```
WHERE city = 'Delhi' AND age > 25
```

---

### ‚ùó When NOT to use indexes

* On small tables
* On columns with high updates
* On columns with low selectivity (e.g., gender, boolean)

Indexes speed reads but slow writes because DB must update index too.

---

# #Ô∏è‚É£ **2. Partitioning (Splitting a BIG table into smaller logical parts)**

Partitioning = breaking a table into **smaller chunks**, but they still live on **same server / same DB system**.

The table is logically one but physically stored separately.

---

## üü¢ Types of Partitioning

### **1. Horizontal Partitioning (Row-based)**

Different rows go to different partitions.

Example:

```
Users Table:
India ‚Üí Partition 1  
USA   ‚Üí Partition 2  
EU    ‚Üí Partition 3
```

### Best for:

* Large tables
* Partition pruning (queries skip irrelevant partitions)

---

### **2. Vertical Partitioning (Column-based)**

Split columns into different tables.

Example:

```
User Basic: id, name, email  
User Extra: id, bio, profilePic, settings
```

Useful when:

* Some columns are accessed frequently
* Some are rarely accessed

---

### **3. Range Partitioning**

Split based on ranges:

```
Date < 2022 ‚Üí partition1  
2022‚Äì2024   ‚Üí partition2  
>2024        ‚Üí partition3
```

Best for:

* Logs
* Time-series data

---

### **4. Hash Partitioning**

Partition by hash of a key:

```
hash(user_id) % 4 ‚Üí partition number
```

Useful when:

* Even distribution is needed
* No natural range exists

---

## üü¢ Benefits of Partitioning

‚úî Faster queries
‚úî Smaller indexes
‚úî Better maintenance
‚úî Old partitions can be archived

## üî¥ Limitation

* Still one server (not horizontally scalable)
* Cannot handle massive traffic alone

---

# #Ô∏è‚É£ **3. Sharding (Horizontal Scalability across multiple servers)**

Sharding = **partitioning across multiple servers** (true horizontal scaling).

Each shard = independent database.

---

# üü¢ Why Sharding?

1. When DB becomes too big for one machine
2. When read/write load becomes too high
3. When partitioning is not enough

Sharding helps systems scale to **millions of users**.

---

# #Ô∏è‚É£ **Types of Sharding**

## **1. Hash-Based Sharding**

```
shard = hash(user_id) % 4
```

### Pros

‚úî Even distribution
‚úî Good for random traffic

### Cons

‚ùå Re-sharding is difficult
‚ùå Cross-shard queries hard

---

## **2. Range-Based Sharding**

```
UserID 1‚Äì1M ‚Üí Shard A  
UserID 1M‚Äì2M ‚Üí Shard B  
‚Ä¶
```

### Pros

‚úî Easy to understand
‚úî Good for sequential IDs

### Cons

‚ùå Hotspot problem (new users all go to last shard)

---

## **3. Geography-Based Sharding**

```
India ‚Üí Shard IN  
USA   ‚Üí Shard US  
EU    ‚Üí Shard EU
```

### Pros

‚úî Low latency
‚úî Natural distribution

### Cons

‚ùå Uneven distribution
‚ùå Hard cross-region consistency

---

## **4. Directory/Lookup Table Sharding**

A separate service tells which shard to use.

```
user_id  | shard
101      | shard1
567      | shard3
999      | shard2
```

Like:

* Uber (drivers)
* Netflix (profiles)

### Pros

‚úî Full control
‚úî Dynamic re-sharding

### Cons

‚ùå Lookup table must be highly available

---

# #Ô∏è‚É£ **Partitioning vs Sharding**

| Feature     | Partitioning         | Sharding               |
| ----------- | -------------------- | ---------------------- |
| Serves      | Same server          | Different servers      |
| Scaling     | Limited              | Unlimited              |
| Use case    | Organize large table | Handle massive traffic |
| Data access | Simple               | Complex (cross-shard)  |
| Cost        | Low                  | High                   |

**Partitioning = single server optimization**
**Sharding = multi-server horizontal scaling**

---

# #Ô∏è‚É£ **Real-world examples**

### üü¶ Netflix

* Cassandra sharding (multi-region)
* User profiles in different shards

### üü• Instagram

* Sharded PostgreSQL
* Redis caching
* Cassandra for feeds

### üü© Uber

* Sharded MySQL
* Lookup service for driver locations

### üüß Amazon DynamoDB

* Auto-sharding
* Hash partitioning

---

# #Ô∏è‚É£ **Architecture Summary**

## **Indexing**

‚úî Faster reads
‚úî Data structure optimization

## **Partitioning**

‚úî Big tables ‚Üí small chunks
‚úî Same server
‚úî Logical splitting

## **Sharding**

‚úî Data split across multiple machines
‚úî Horizontal scalability
‚úî Massive performance gain

---

# #Ô∏è‚É£ **Interview-ready One-Liners**

### **What is Indexing?**

> Data structure (like B-tree) to speed up search by avoiding full table scans.

### **What is Partitioning?**

> Breaking a table into logical parts for better query performance.

### **What is Sharding?**

> Distributing data across multiple servers for horizontal scaling.

### **Partitioning vs Sharding?**

> Partitioning = same server, logical.
> Sharding = multiple servers, horizontal scale.

### **Why sharding is hard?**

> Cross-shard joins, transactions, rebalancing, routing logic.
