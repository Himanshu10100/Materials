Great ðŸš€ Letâ€™s explore **Hoisting in JavaScript** step by step.

---

# ðŸ”¹ What is Hoisting?

**Hoisting** is JavaScriptâ€™s default behavior of **moving declarations to the top of their scope** (before code execution).
ðŸ‘‰ But **only declarations** are hoisted, **not initializations**.

---

# 1ï¸âƒ£ **Hoisting with `var`**

* Variables declared with `var` are **hoisted** to the top of their scope.
* Their value is **initialized as `undefined`** until assigned.

```js
console.log(a); // âœ… undefined (not error, because hoisted)
var a = 5;
console.log(a); // 5
```

---

# 2ï¸âƒ£ **Hoisting with `let` and `const`**

* `let` and `const` are also **hoisted**, but they stay in a **Temporal Dead Zone (TDZ)** until defined.
* Accessing them before declaration throws a **ReferenceError**.

```js
// console.log(b); // âŒ ReferenceError
let b = 10;

const c = 20;
console.log(c); // âœ… 20
```

---

# 3ï¸âƒ£ **Function Hoisting**

* **Function Declarations** are hoisted **with their body**.
  â†’ Can call them before they are defined.

```js
sayHello(); // âœ… Works

function sayHello() {
  console.log("Hello!");
}
```

* **Function Expressions (var, let, const)** are hoisted like variables.
  â†’ The variable is hoisted, but the function assignment is **not**.

```js
// greet(); âŒ TypeError (because greet is undefined at this point)
var greet = function () {
  console.log("Hi!");
};
```

```js
// greet(); âŒ ReferenceError (TDZ)
let greet = function () {
  console.log("Hi!");
};
```

---

# 4ï¸âƒ£ **Class Hoisting**

* Classes are **not hoisted** like functions.
* You must declare a class **before using it**.

```js
// const obj = new MyClass(); âŒ ReferenceError
class MyClass {}
```

---

# ðŸ”¹ Summary Table

| Keyword                           | Hoisted?          | Initial Value Before Declaration | Usable Before Declaration? |
| --------------------------------- | ----------------- | -------------------------------- | -------------------------- |
| `var`                             | âœ… Yes             | `undefined`                      | âœ… (but undefined)          |
| `let`                             | âœ… Yes             | TDZ (no value)                   | âŒ ReferenceError           |
| `const`                           | âœ… Yes             | TDZ (no value)                   | âŒ ReferenceError           |
| Function Declaration              | âœ… Yes (with body) | Actual function                  | âœ…                          |
| Function Expression (`var`)       | âœ… Variable only   | `undefined`                      | âŒ TypeError                |
| Function Expression (`let/const`) | âœ… Variable only   | TDZ                              | âŒ ReferenceError           |
| Class                             | âŒ No              | â€”                                | âŒ ReferenceError           |

---

âœ… **Key Takeaways**

* Hoisting moves declarations to the top, but **not initializations**.
* `var` is risky â†’ leads to bugs due to undefined values.
* Use `let` & `const` for block scope & safety.
* Functions declared with `function` keyword are fully hoisted.

---

Would you like me to now create **10 Hoisting practice questions with answers** (like I did for operators)?

Great follow-up ðŸš€ â€” letâ€™s connect **Arrow Functions** with **Hoisting** in both **JavaScript** and **React**.

---

# ðŸ”¹ 1. Hoisting Recap

In JS:

* **Function Declarations** are hoisted completely â†’ you can call them before theyâ€™re defined.
* **Variable Declarations (`var`)** are hoisted but initialized as `undefined`.
* **`let` and `const`** are hoisted too, but theyâ€™re in the **Temporal Dead Zone (TDZ)** â†’ you canâ€™t use them before their line of code.

---

# ðŸ”¹ 2. Arrow Functions and Hoisting in JavaScript

ðŸ‘‰ **Arrow functions are *not* hoisted like function declarations.**
They behave like **function expressions**, meaning:

* The **variable name** is hoisted (if declared with `var`), but not the function definition.
* With `let` / `const`, you cannot access them before the line of definition.

### Example 1 â€“ Function Declaration vs Arrow Function

```js
// âœ… Works: function declaration is hoisted
sayHello();
function sayHello() {
  console.log("Hello!");
}

// âŒ Error: Cannot access before initialization
sayHi(); 
const sayHi = () => {
  console.log("Hi!");
};
```

---

### Example 2 â€“ With `var`

```js
sayBye(); // âŒ TypeError: sayBye is not a function
var sayBye = () => {
  console.log("Bye!");
};
```

âž¡ï¸ Why? Because only `var sayBye` is hoisted as `undefined`.
So `sayBye()` becomes `undefined()` â†’ error.

---

# ðŸ”¹ 3. Arrow Functions and Hoisting in React

In **React**, arrow functions are often used inside components or hooks. Since theyâ€™re **expressions**, **they are not hoisted**.

### Example â€“ Event Handler

```jsx
function App() {
  // âŒ Will throw ReferenceError if called before line of definition
  // handleClick(); 

  const handleClick = () => {
    alert("Clicked!");
  };

  return <button onClick={handleClick}>Click Me</button>;
}
```

âš¡ **Key Point:**

* In React, arrow functions are usually **defined inside the component body**, so hoisting doesnâ€™t matter â€” theyâ€™re evaluated when the component renders.
* If you **try to call them before definition inside the same function**, youâ€™ll get a **ReferenceError**.

---

# ðŸ”¹ 4. When it Matters

* In **plain JS scripts**, hoisting differences matter a lot (you can call a declared function anywhere, but not arrow functions).
* In **React**, since functions are usually inside components, you rarely call them before theyâ€™re defined â†’ so hoisting issues donâ€™t usually bite you.

---

âœ… **Summary**

* **JS**: Arrow functions are **not hoisted** â†’ only their variable declaration is hoisted.
* **React**: Arrow functions inside components are **evaluated at render time**; you canâ€™t call them before definition.
* Always define arrow functions before using them.

---

ðŸ‘‰ Do you want me to also show **how hoisting works differently with arrow functions inside `useEffect` vs outside (global scope)**?
